import html
import logging
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import re
from langchain_core.documents import Document  

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class DialogManager:
    """
    Implements a dialog-based process for creating an e-learning course.
    """

    def __init__(self, template_manager, llm_manager, vector_store_manager):
        """
        Initializes the DialogManager.

        Args:
            template_manager: TemplateManager instance
            llm_manager: LLMManager instance
            vector_store_manager: VectorStoreManager instance
        """
        self.template_manager = template_manager
        self.llm_manager = llm_manager
        self.vector_store_manager = vector_store_manager

        # Initialize conversation state
        self.conversation_state = {
            "current_step": "greeting",
            "context_info": {},
            "section_responses": {},
            "generated_content": {},  # Content generated by LLM per section
            "completed_sections": [],
            "current_section": None,
            "content_quality_checks": {},
            "current_section_question_count": 0,
            "question_error_count": 0
        }

        # List of context questions
        self.context_questions = [
        "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?",
        "Welche Mitarbeitergruppen sollen geschult werden?",
        "Wie lang sollte der E-Learning-Kurs maximal dauern?",
        "Mit welchen Arten von Informationen oder Daten arbeiten Ihre Mitarbeiter im Alltag?",
        "Wie kommunizieren Ihre Mitarbeiter typischerweise miteinander und mit externen Partnern?"
        ]

    def get_next_question(self) -> str:
        """
        Determines the next question based on the current conversation state.

        Returns:
            Next question as a string
        """
        if self.conversation_state["current_step"] == "greeting":
            # Switch to next step
            self.conversation_state["current_step"] = "context_gathering"
            return "Willkommen! Ich unterstütze Sie heute bei der Erstellung eines maßgeschneiderten E-Learning-Kurses zur Informationssicherheit. Um einen auf Ihre Bedürfnisse zugeschnittenen Kurs zu entwickeln, würde ich gerne mehr über Ihre Organisation erfahren. Für welche Art von Organisation erstellen wir diesen Kurs?"

        elif self.conversation_state["current_step"] == "context_gathering":
            # Find the next unanswered context question
            for question in self.context_questions:
                if question not in self.conversation_state["context_info"]:
                    return question

            # All context questions have been answered
            self.conversation_state["current_step"] = "template_navigation"
            return "Vielen Dank für diese Informationen! Jetzt werde ich Ihnen einige Fragen zu spezifischen Bereichen der Informationssicherheit stellen, damit wir einen gut angepassten Kurs erstellen können.\n\n" + self.get_next_template_question()

        elif self.conversation_state["current_step"] == "template_navigation":
            return self.get_next_template_question()

        elif self.conversation_state["current_step"] == "review":
            return "Ich habe basierend auf Ihren Eingaben einen E-Learning-Kurs zur Informationssicherheit entworfen. Möchten Sie das Ergebnis sehen?"

        elif self.conversation_state["current_step"] == "completion":
            return "Vielen Dank für Ihre Mitwirkung! Der E-Learning-Kurs wurde erfolgreich erstellt und kann jetzt heruntergeladen werden."
        
        # Default fallback
        return "Wie kann ich Ihnen mit Ihrem E-Learning-Kurs zur Informationssicherheit weiterhelfen?"

    def get_next_template_question(self) -> str:
        """
        Determines the next question based on the template with robust error handling.

        Returns:
            Next question as a string
        """
        # Predefined questions for emergencies
        predefined_questions = {
            "threat_awareness": "Wie sieht ein typischer Arbeitstag in Ihrem Unternehmen aus, besonders in Bezug auf den Umgang mit externen E-Mails oder Informationen?",
            "threat_identification": "Sind Ihnen schon einmal verdächtige E-Mails oder andere Kommunikation aufgefallen? Was hat Sie stutzig gemacht?",
            "threat_impact_assessment": "Welche Auswirkungen hätte es auf Ihre tägliche Arbeit, wenn wichtige Daten plötzlich nicht mehr verfügbar wären?",
            "tactic_choice": "Wie gehen Sie aktuell vor, wenn Sie etwas Verdächtiges bemerken?",
            "tactic_justification": "Warum halten Sie die aktuellen Sicherheitsmaßnahmen in Ihrem Unternehmen für sinnvoll?",
            "tactic_mastery": "Welche konkreten Schritte unternehmen Sie, wenn Sie eine verdächtige E-Mail erhalten?",
            "tactic_check_follow_up": "Was passiert in Ihrem Unternehmen, nachdem ein Sicherheitsvorfall gemeldet wurde?"
        }

        try:
            # Find the next uncompleted section
            next_section = self.template_manager.get_next_section(self.conversation_state["completed_sections"])

            if next_section is None:
                # All sections have been completed
                self.conversation_state["current_step"] = "review"
                return self.get_next_question()

            # Check if we're switching to a new section
            current_section = self.conversation_state.get("current_section")
            is_new_section = current_section != next_section["id"]

            # Initialize question_error_count if not present or reset for new section
            if is_new_section:
                # Reset counters for new section
                self.conversation_state["current_section_question_count"] = 0
                self.conversation_state["question_error_count"] = 0

            # Section information
            section_id = next_section["id"]
            section_title = next_section["title"]
            section_description = next_section["description"]
            section_type = next_section.get("type", "generic")
            
            # User-friendly questions mapping
            user_friendly_questions = {
                "threat_awareness": "Wie sieht ein typischer Arbeitstag in Ihrem Unternehmen aus, besonders wenn Sie mit Informationen oder Kommunikation arbeiten?",
                "threat_identification": "Ist Ihnen schon einmal etwas Ungewöhnliches oder Verdächtiges bei der Arbeit aufgefallen? Zum Beispiel seltsame E-Mails oder Anrufe?",
                "threat_impact_assessment": "Was würde in Ihrem Unternehmen passieren, wenn plötzlich wichtige Daten oder Systeme nicht mehr verfügbar wären?",
                "tactic_choice": "Wie gehen Sie vor, wenn Sie etwas Verdächtiges bemerken? Haben Sie bestimmte Abläufe oder Ansprechpartner?",
                "tactic_justification": "Was sind die Gründe für Ihre derzeitigen Sicherheitsmaßnahmen in Ihrem Unternehmen?",
                "tactic_mastery": "Können Sie mir konkrete Schritte oder Prozesse beschreiben, wie Sie mit vertraulichen Informationen umgehen?",
                "tactic_check_follow_up": "Was passiert in Ihrem Unternehmen nach einem Vorfall oder einer Störung? Wie wird das nachverfolgt?"
            }

            try:
                # Get relevant documents for this section
                retrieval_queries = self.generate_retrieval_queries(section_title, section_id)

                retrieved_docs = self.vector_store_manager.retrieve_with_multiple_queries(
                    queries=retrieval_queries,
                    filter={"section_type": section_type},
                    top_k=2  # Reduce to 2 instead of 3 for less memory usage
                )

                # Limit context to max. 1000 characters
                context_text = "\n\n".join([doc.page_content for doc in retrieved_docs])
                if len(context_text) > 1000:
                    context_text = context_text[:1000] + "..."

                # Context information for question generation
                organization = self.conversation_state["context_info"].get(
                    "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")
                audience = self.conversation_state["context_info"].get(
                    "Welche Mitarbeitergruppen sollen geschult werden?", "")

                # Try to generate question with LLM
                question = self.llm_manager.generate_question(
                    section_title=section_title,
                    section_description=section_description,
                    context_text=context_text,
                    organization=organization,
                    audience=audience
                )

                # Reset error counter on success
                self.conversation_state["question_error_count"] = 0

            except Exception as e:
                # Log error
                logger.error(f"Error during question generation for {section_title}: {e}")

                # Increase error counter
                self.conversation_state["question_error_count"] += 1

                # Skip to next section if too many errors
                if self.conversation_state["question_error_count"] > 2:
                    logger.warning(f"Too many errors with {section_title}, skipping section")
                    self.conversation_state["completed_sections"].append(section_id)
                    return self.get_next_template_question()

                # Use predefined question as fallback
                question = user_friendly_questions.get(section_id, 
                                                      predefined_questions.get(section_type, 
                                                                             f"Können Sie mir mehr über {section_title} in Ihrem Arbeitsalltag erzählen?"))

            # Update the conversation state
            self.conversation_state["current_section"] = section_id

            # Add transition info for new section
            friendly_section_names = {
                "threat_awareness": "typische Arbeitssituationen",
                "threat_identification": "ungewöhnliche Vorkommnisse",
                "threat_impact_assessment": "mögliche Auswirkungen von Störungen",
                "tactic_choice": "Ihre Handlungsmöglichkeiten",
                "tactic_justification": "die Gründe für bestimmte Maßnahmen",
                "tactic_mastery": "konkrete Schritte im Arbeitsalltag",
                "tactic_check_follow_up": "Nachverfolgung von Vorfällen"
            }
            
            if is_new_section:
                friendly_name = friendly_section_names.get(section_id, section_title)
                return f"Nun sprechen wir über {friendly_name}.\n\n{question}"

            return question
            
        except Exception as e:
            logger.error(f"Error in get_next_template_question: {e}")
            # General fallback if something unexpected happens
            section_id = self.conversation_state.get("current_section")
            if section_id:
                return predefined_questions.get(section_id, "Können Sie mir mehr über Ihre tägliche Arbeit erzählen?")
            else:
                return "Können Sie mir mehr über Ihre tägliche Arbeit erzählen?"

    def generate_retrieval_queries(self, section_title: str, section_id: str) -> List[str]:
        """
        Generates retrieval queries for a section of the template.

        Args:
            section_title: Title of the section
            section_id: ID of the section

        Returns:
            List of retrieval queries
        """
        try:
            # Base query from the section title
            base_query = section_title

            # Context-specific queries
            organization = self.conversation_state["context_info"].get(
                "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")
            audience = self.conversation_state["context_info"].get(
                "Welche Mitarbeitergruppen sollen geschult werden?", "")
            compliance = self.conversation_state["context_info"].get(
                "Gibt es spezifische Compliance-Anforderungen oder Branchenstandards, die berücksichtigt werden müssen?", "")

            # Industry-specific query
            industry_query = f"Informationssicherheit für {organization}"

            # Improved section-specific query templates according to the example script
            section_templates = {
                "threat_awareness": f"Bedrohungsbewusstsein Kontext Informationssicherheit {organization}",
                "threat_identification": f"Merkmale Bedrohungserkennung Informationssicherheit {organization}",
                "threat_impact_assessment": f"Konsequenzen Bedrohungen Informationssicherheit {organization}",
                "tactic_choice": f"Handlungsoptionen Sicherheitsmaßnahmen {organization}",
                "tactic_justification": f"Begründung Rechtfertigung Sicherheitsmaßnahmen {organization}",
                "tactic_mastery": f"Konkrete Schritte Umsetzung Sicherheitsmaßnahmen {organization}",
                "tactic_check_follow_up": f"Anschlusshandlungen Nach Sicherheitsvorfall {organization}"
            }

            # Use the corresponding template if available
            section_query = section_templates.get(section_id, "")

            # Add compliance-specific query if available
            compliance_query = ""
            if compliance and compliance.strip():
                compliance_query = f"Informationssicherheit {compliance} {organization}"

            # Specific queries for certain sections
            specific_queries = []
            if section_id == "threat_awareness":
                specific_queries.append(f"Alltägliche Situationen Informationssicherheit {organization}")
            elif section_id == "threat_identification":
                specific_queries.append(f"Phishing Erkennung Merkmale {organization}")
            elif section_id == "threat_impact_assessment":
                specific_queries.append(f"Konsequenzen Datenverlust Cyberangriff {organization}")
            elif section_id == "tactic_choice":
                specific_queries.append(f"Schutzmaßnahmen Verdächtige E-Mails {organization}")
            elif section_id == "tactic_justification":
                specific_queries.append(f"Warum E-Mail-Sicherheit wichtig {organization}")
            elif section_id == "tactic_mastery":
                specific_queries.append(f"Schritte Überprüfung Verdächtige E-Mails {organization}")
            elif section_id == "tactic_check_follow_up":
                specific_queries.append(f"Meldeverfahren Informationssicherheitsvorfälle {organization}")

            # Create the list of queries
            queries = [base_query, industry_query]

            if section_query:
                queries.append(section_query)

            if compliance_query:
                queries.append(compliance_query)

            queries.extend(specific_queries)
            
            # Log the queries for debugging
            logger.info(f"Generated {len(queries)} retrieval queries for section '{section_id}'")
            
            # Validate that queries is a list
            if not isinstance(queries, list):
                logger.error(f"queries is not a list, got {type(queries)}: {queries}")
                return []  # Return empty list as fallback
                
            return queries
            
        except Exception as e:
            # Log the error and return an empty list as fallback
            logger.error(f"Error generating retrieval queries for section '{section_id}': {e}")
            return []  # Always return a list, even if empty, to prevent type errors

    def process_user_response(self, response: str) -> str:
        """
        Processes the user's response and updates the conversation state.

        Args:
            response: User's response

        Returns:
            Next question or message
        """
        try:
            # Handle context gathering phase
            if self.conversation_state["current_step"] == "context_gathering":
                # Determine which context question is currently being answered
                for question in self.context_questions:
                    if question not in self.conversation_state["context_info"]:
                        self.conversation_state["context_info"][question] = response
                        break

                # Check if all context questions have been answered
                all_answered = all(question in self.conversation_state["context_info"] 
                                for question in self.context_questions)
                
                if all_answered:
                    # Transition to template navigation
                    self.conversation_state["current_step"] = "template_navigation"
                    # Log completion of context gathering
                    logger.info("Context gathering completed, transitioning to template navigation")

            # Handle template navigation phase
            elif self.conversation_state["current_step"] == "template_navigation":
                # Ensure we have a valid current section
                current_section = self.conversation_state.get("current_section")
                if not current_section:
                    logger.error("Current section is None when processing response")
                    self.conversation_state["current_step"] = "review"
                    return "Es ist ein Problem aufgetreten. Möchten Sie den bisher erstellten E-Learning-Kurs ansehen?"

                # Increase the question counter for the current section
                self.conversation_state["current_section_question_count"] += 1

                # Check if we've reached the maximum number of questions or if the answer is sufficient
                max_questions_reached = self.conversation_state["current_section_question_count"] >= 3

                if max_questions_reached or self.is_response_adequate(response):
                    # Save the response for the current section
                    self.conversation_state["section_responses"][current_section] = response

                    try:
                        # Generate content for this section
                        logger.info(f"Generating content for section {current_section}")
                        self._generate_section_content(current_section)
                    except Exception as content_error:
                        # Handle errors in content generation
                        logger.error(f"Error generating content for section {current_section}: {content_error}")
                        # Store a placeholder in case of error
                        self.conversation_state["generated_content"][current_section] = (
                            f"Inhalt für diesen Abschnitt konnte nicht generiert werden. "
                            f"Bitte versuchen Sie es später erneut."
                        )

                    # Mark section as completed
                    self.conversation_state["completed_sections"].append(current_section)

                    # Reset the question counter for the next section
                    self.conversation_state["current_section_question_count"] = 0
                    
                    # Log completion of this section
                    logger.info(f"Completed section {current_section}, moving to next section")
                else:
                    # Response is not adequate, generate a follow-up question
                    try:
                        followup = self.generate_followup_question(response)
                        # Ensure followup is a string
                        if not isinstance(followup, str):
                            logger.error(f"Follow-up question is not a string: {type(followup)}")
                            followup = "Könnten Sie bitte etwas ausführlicher antworten? Ihre Erfahrungen sind wichtig für die Erstellung eines maßgeschneiderten Kurses."
                        return followup
                    except Exception as followup_error:
                        logger.error(f"Error generating follow-up question: {followup_error}")
                        return "Vielen Dank für Ihre Antwort. Könnten Sie vielleicht noch etwas konkreter werden? Beispiele aus Ihrem Arbeitsalltag wären besonders hilfreich."

            # Handle review phase
            elif self.conversation_state["current_step"] == "review":
                # Check if the user wants to see the result
                if any(word in response.lower() for word in ["ja", "gerne", "zeigen", "ansehen"]):
                    self.conversation_state["current_step"] = "completion"
                    try:
                        summary = self.get_script_summary()
                        # Ensure summary is a string
                        if not isinstance(summary, str):
                            logger.error(f"Script summary is not a string: {type(summary)}")
                            summary = "Leider konnte die Kurszusammenfassung nicht erstellt werden."
                        return "Hier ist der entworfene E-Learning-Kurs zur Informationssicherheit basierend auf Ihren Eingaben:\n\n" + summary
                    except Exception as summary_error:
                        logger.error(f"Error generating script summary: {summary_error}")
                        return "Es ist ein Fehler bei der Erstellung des E-Learning-Kurses aufgetreten. Bitte versuchen Sie es erneut."
                else:
                    # Ask again if the user wants to see the result
                    return "Möchten Sie den erstellten E-Learning-Kurs sehen? Bitte antworten Sie mit 'Ja' oder 'Nein'."

            # Determine the next question
            try:
                next_question = self.get_next_question()
                # Ensure next_question is a string
                if not isinstance(next_question, str):
                    logger.error(f"Next question is not a string: {type(next_question)}")
                    next_question = "Wie kann ich Ihnen mit Ihrem E-Learning-Kurs weiterhelfen?"
                return next_question
            except Exception as question_error:
                logger.error(f"Error getting next question: {question_error}")
                return "Wie kann ich Ihnen mit Ihrem E-Learning-Kurs zur Informationssicherheit weiterhelfen?"

        except Exception as e:
            # Catch-all error handler for the entire method
            logger.error(f"Unexpected error in process_user_response: {e}")
            # Provide a user-friendly message and try to continue the conversation
            self.conversation_state["current_step"] = "template_navigation"
            return "Es tut mir leid, bei der Verarbeitung Ihrer Antwort ist ein Fehler aufgetreten. Lassen Sie uns mit einer anderen Frage fortfahren."

    def is_response_adequate(self, response: str) -> bool:
        """
        Checks if the user's response is sufficiently detailed.

        Args:
            response: User's response

        Returns:
            True if the response is sufficient, False otherwise
        """
        # Improved heuristic: Check the length and content of the response
        min_word_count = 15
        word_count = len(response.split())

        # Check if the response is relevant to the current section
        current_section_id = self.conversation_state["current_section"]
        current_section = self.template_manager.get_section_by_id(current_section_id)

        if current_section:
            # Create a list of relevant terms for this section
            relevant_terms = []

            if "threat" in current_section_id:
                relevant_terms.extend(["gefahr", "risiko", "bedrohung", "sicherheit", "schaden"])
            if "tactic" in current_section_id:
                relevant_terms.extend(["maßnahme", "vorgehen", "schutz", "handlung", "prozess"])

            # Check if at least one relevant term appears in the response
            has_relevant_term = any(term in response.lower() for term in relevant_terms)

            return word_count >= min_word_count and has_relevant_term

        return word_count >= min_word_count

    def generate_followup_question(self, response: str) -> str:
        """
        Generates a follow-up question for an insufficient response.

        Args:
            response: Insufficient response from the user

        Returns:
            Follow-up question as a string
        """
        current_section_id = self.conversation_state["current_section"]
        
        if not current_section_id:
            return "Können Sie bitte etwas ausführlicher auf die Frage eingehen?"
            
        section = self.template_manager.get_section_by_id(current_section_id)
        
        if not section:
            return "Können Sie bitte etwas ausführlicher auf die Frage eingehen?"

        followup_prompt = f"""
        Die folgende Antwort des Kunden zu einer Frage über {section['title']} ist recht kurz oder allgemein:

        "{response}"

        Formuliere eine freundliche Nachfrage, die mehr Details zu ihren Prozessen oder ihrem Arbeitskontext erbittet.
        Die Nachfrage sollte:
        1. Wertschätzend für die bisherige Antwort sein
        2. Konkrete Aspekte ansprechen, zu denen mehr Details hilfreich wären
        3. Keine Fachbegriffe aus der Informationssicherheit verwenden
        4. Offen formuliert sein, um ausführlichere Antworten zu fördern
        5. Auf den spezifischen Abschnittstyp "{section['title']}" zugeschnitten sein

        Für "Threat Awareness" beispielsweise könntest du nach konkreten Situationen im Arbeitsalltag fragen.
        Für "Tactic Mastery" könntest du nach spezifischen Schritten in bestimmten Prozessen fragen.

        Stelle nur die Nachfrage, keine Einleitung oder zusätzliche Erklärungen.
        """

        try:
            followup_question = self.llm_manager.llm(followup_prompt)
            return followup_question
        except Exception as e:
            logger.error(f"Error generating followup question: {e}")
            return "Vielen Dank für Ihre Antwort. Könnten Sie vielleicht noch etwas konkreter werden? Beispiele aus Ihrem Arbeitsalltag wären besonders hilfreich."

    def _generate_section_content(self, section_id: str) -> None:
        """
        Generates the content for a section and performs quality checks.

        Args:
            section_id: ID of the section
        """
        logger.info(f"Starting content generation for section: {section_id}")
        
        try:
            # Get the user's response
            user_response = self.conversation_state["section_responses"].get(section_id, "")
            if not user_response:
                logger.error(f"No user response found for section {section_id}")
                self.conversation_state["generated_content"][section_id] = f"Inhalt für {section_id} konnte nicht generiert werden. Keine Antwort vorhanden."
                return
                    
            # Get the section details from the template
            section = self.template_manager.get_section_by_id(section_id)
            if not section:
                logger.error(f"Section {section_id} not found in template")
                self.conversation_state["generated_content"][section_id] = f"Inhalt für {section_id} konnte nicht generiert werden. Abschnitt nicht gefunden."
                return

            # STEP 1: Extract key information for retrieval
            try:
                # Get key concepts from user response
                key_concepts = self.llm_manager.extract_key_information(
                    section_type=section.get("type", "generic"),
                    user_response=user_response
                )
                
                # Defensive type checking - ensure key_concepts is a list
                if not isinstance(key_concepts, list):
                    logger.error(f"key_concepts is not a list, got {type(key_concepts)}: {key_concepts}")
                    # Convert to list if possible, or use empty list as fallback
                    if isinstance(key_concepts, str):
                        key_concepts = [key_concepts]
                    elif isinstance(key_concepts, (int, float)):
                        logger.error(f"Got numeric value ({key_concepts}) instead of list of concepts")
                        key_concepts = []
                    else:
                        key_concepts = []
                        
                logger.info(f"Extracted {len(key_concepts)} key concepts for section {section_id}")
                
            except Exception as e:
                logger.error(f"Error extracting key information: {e}")
                key_concepts = []  # Use empty list as fallback

            # STEP 2: Generate retrieval queries based on key concepts
            retrieval_queries = []
            try:
                # Build queries from key concepts
                for concept in key_concepts:
                    if isinstance(concept, str) and concept.strip():
                        retrieval_queries.append(f"{concept} Informationssicherheit")
                
                # Add section-specific queries
                additional_queries = self.generate_retrieval_queries(section["title"], section_id)
                
                # Validate additional_queries is a list
                if not isinstance(additional_queries, list):
                    logger.error(f"additional_queries is not a list, got {type(additional_queries)}")
                    # Try to convert or use an empty list
                    if hasattr(additional_queries, '__iter__') and not isinstance(additional_queries, (str, bytes)):
                        additional_queries = list(additional_queries)
                    else:
                        additional_queries = []
                        
                # Add the additional queries
                retrieval_queries.extend(additional_queries)
                
                logger.info(f"Generated {len(retrieval_queries)} total retrieval queries")
                
            except Exception as e:
                logger.error(f"Error generating retrieval queries: {e}")
                # If we have no queries at this point, add a basic fallback query
                if not retrieval_queries:
                    retrieval_queries = [f"Informationssicherheit {section_id}"]

            # STEP 3: Retrieve relevant documents
            try:
                # Get relevant documents using the queries
                retrieved_docs = self.vector_store_manager.retrieve_with_multiple_queries(
                    queries=retrieval_queries,
                    filter={"section_type": section.get("type", "generic")},
                    top_k=5
                )
                
                # Validate retrieved_docs is a list
                if not isinstance(retrieved_docs, list):
                    logger.error(f"retrieved_docs is not a list, got {type(retrieved_docs)}")
                    retrieved_docs = []
                    
                logger.info(f"Retrieved {len(retrieved_docs)} documents for context")
                
            except Exception as e:
                logger.error(f"Error retrieving documents: {e}")
                retrieved_docs = []  # Use empty list as fallback

            # STEP 4: Extract context from retrieved documents
            context_text = ""
            try:
                # Join document contents into a single context string
                if retrieved_docs:
                    context_text = "\n\n".join([
                        doc.page_content for doc in retrieved_docs 
                        if hasattr(doc, 'page_content') and isinstance(doc.page_content, str)
                    ])
                    
                else:
                    # If no documents were retrieved, use a minimal context
                    context_text = f"Bitte erstellen Sie Inhalte zum Thema {section['title']} für Informationssicherheitsschulungen."
                    
            except Exception as e:
                logger.error(f"Error creating context text: {e}")
                # Fallback to minimal context
                context_text = f"Informationssicherheit Schulung für {section['title']}"

            # STEP 5: Generate content using LLM
            try:
                # Get organization, audience and duration info
                organization = self.conversation_state["context_info"].get(
                    "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")
                audience = self.conversation_state["context_info"].get(
                    "Welche Mitarbeitergruppen sollen geschult werden?", "")
                duration = self.conversation_state["context_info"].get(
                    "Wie lang sollte der E-Learning-Kurs maximal dauern?", "")

                # Generate content with the LLM
                content = self.llm_manager.generate_content(
                    section_title=section["title"],
                    section_description=section.get("description", ""),
                    user_response=user_response,
                    organization=organization,
                    audience=audience,
                    duration=duration,
                    context_text=context_text
                )
                
                # Validate content is a string
                if not isinstance(content, str):
                    logger.error(f"Generated content is not a string, got {type(content)}")
                    # Try to convert to string or use fallback
                    content = str(content) if content is not None else f"Inhalt für {section['title']} konnte nicht generiert werden."
                    
                logger.info(f"Successfully generated content for section {section_id} ({len(content)} chars)")
                
            except Exception as e:
                logger.error(f"Error generating content: {e}")
                # Fallback content
                content = f"Für diesen Abschnitt ({section['title']}) konnte kein Inhalt generiert werden. Bitte versuchen Sie es später erneut."

            # STEP 6: Perform quality checks on generated content
            try:
                # Check for hallucinations if we have content
                if content:
                    # Perform advanced hallucination check
                    advanced_check = self.llm_manager.advanced_hallucination_detection(content)
                    
                    # Validate advanced_check is a dictionary
                    if not isinstance(advanced_check, dict):
                        logger.error(f"advanced_check is not a dictionary, got {type(advanced_check)}")
                        advanced_check = {
                            "confidence_score": 0.5,
                            "suspicious_sections": []
                        }
                    
                    # Perform standard hallucination check
                    has_issues, verified_content = self.llm_manager.check_hallucinations(
                        content=content,
                        user_input=user_response,
                        context_text=context_text
                    )
                    
                    # Verify output is a string
                    if not isinstance(verified_content, str):
                        logger.error(f"verified_content is not a string, got {type(verified_content)}")
                        verified_content = content  # Fallback to original content
                    
                    # Save the result of the quality check
                    self.conversation_state["content_quality_checks"][section_id] = {
                        "has_issues": has_issues,
                        "confidence_score": advanced_check.get("confidence_score", 0.5),
                        "suspicious_sections": advanced_check.get("suspicious_sections", [])
                    }
                    
                    # Use the verified content
                    content = verified_content
                    
                else:
                    # No content to check
                    self.conversation_state["content_quality_checks"][section_id] = {
                        "has_issues": True,
                        "confidence_score": 0.0,
                        "suspicious_sections": ["No content generated"]
                    }
                    
            except Exception as e:
                logger.error(f"Error during quality checks: {e}")
                # Don't let quality check failure prevent content delivery
                self.conversation_state["content_quality_checks"][section_id] = {
                    "has_issues": True,
                    "confidence_score": 0.0,
                    "suspicious_sections": [f"Error during quality check: {str(e)}"]
                }

            # STEP 7: Save the generated content
            self.conversation_state["generated_content"][section_id] = content
            logger.info(f"Content generation completed for section {section_id}")
            
        except Exception as e:
            # Master exception handler to ensure the method never crashes
            logger.error(f"Unhandled error generating content for section {section_id}: {e}")
            # Set a fallback content
            self.conversation_state["generated_content"][section_id] = f"Für diesen Abschnitt konnte kein Inhalt generiert werden. Fehler: {str(e)}"
            # Also save a record of the error in the quality checks
            self.conversation_state["content_quality_checks"][section_id] = {
                "has_issues": True,
                "confidence_score": 0.0,
                "suspicious_sections": [f"Fehler bei der Inhaltsgenerierung: {str(e)}"]
            }

    def generate_script(self) -> Dict[str, Any]:
        """
        Generates the final e-learning course.

        Returns:
            Course as a dictionary
        """
        # Create a script from the generated contents
        try:
            script = self.template_manager.create_script_from_responses(
                self.conversation_state["generated_content"],
                self.conversation_state["context_info"]
            )
            return script
        except Exception as e:
            logger.error(f"Error generating script: {e}")
            # Create a minimal script if there's an error
            return {
                "title": "E-Learning-Kurs zur Informationssicherheit",
                "description": "Bei der Generierung dieses Kurses ist ein Fehler aufgetreten.",
                "sections": [
                    {
                        "id": "error",
                        "title": "Fehler bei der Generierung",
                        "content": f"Bei der Generierung des Skripts ist ein Fehler aufgetreten: {str(e)}"
                    }
                ]
            }

    def get_script_summary(self) -> str:
        """
        Creates a summary of the generated course in the format of the example script.

        Returns:
            Summary as a string
        """
        try:
            # Generate the course
            script = self.generate_script()

            # Create a summary in the format of the example script
            organization = self.conversation_state["context_info"].get(
                "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")

            summary = f"# {script.get('title', 'E-Learning-Kurs zur Informationssicherheit')}\n\n"

            if "description" in script:
                summary += f"{script['description']}\n\n"

            # Format the sections in the desired table format
            for section in script["sections"]:
                title = section["title"]
                content = section.get("content", "Kein Inhalt verfügbar.")

                summary += f"## {title}\n\n"
                summary += f"{content}\n\n"

                # Add note on quality check if relevant
                section_id = section["id"]
                if section_id in self.conversation_state["content_quality_checks"]:
                    quality_check = self.conversation_state["content_quality_checks"][section_id]
                    if quality_check.get("has_issues", False):
                        summary += "*Hinweis: Dieser Abschnitt wurde nach der Qualitätsprüfung überarbeitet.*\n\n"

            # Add closing message, similar to the example script
            summary += "Sie können das Wissen jetzt bei Ihrer Arbeit umsetzen. Dadurch steigern Sie das\n"
            summary += f"Sicherheitsbewusstsein in {organization} und Sie schützen sich, Ihre Kolleginnen\n"
            summary += "und Kollegen und die gesamte Organisation.\n\n"
            summary += "Gut gemacht!\n"

            return summary
        except Exception as e:
            logger.error(f"Error creating script summary: {e}")
            return f"Bei der Erstellung der Zusammenfassung ist ein Fehler aufgetreten: {str(e)}"

    def generate_html_script(self) -> str:
        """
        Generates an HTML version of the script in the format of the example script.

        Returns:
            HTML-formatted script
        """
        try:
            script = self.generate_script()
            organization = self.conversation_state["context_info"].get(
                "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")

            html_output = f"""<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>{html.escape(script.get('title', 'E-Learning-Kurs zur Informationssicherheit'))}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h1 {{ color: #2c3e50; }}
                .section {{ margin-bottom: 20px; }}
                .section-title {{ background-color: #f5f5f5; padding: 10px; font-weight: bold; }}
                .section-content {{ padding: 10px; }}
                .footer {{ margin-top: 30px; border-top: 1px solid #ddd; padding-top: 15px; }}
            </style>
        </head>
        <body>
            <h1>{html.escape(script.get('title', 'E-Learning-Kurs zur Informationssicherheit'))}</h1>
            <p>{html.escape(script.get('description', ''))}</p>
        """

            # Add the sections
            for section in script["sections"]:
                title = section["title"]
                content = section.get("content", "Kein Inhalt verfügbar.")

                html_output += f"""    <div class="section">
                <div class="section-title">{html.escape(title)}</div>"""

                # Process content with backslashes outside the f-string
                escaped_content = html.escape(content).replace('\n', '<br>')
                html_output += f"""
                <div class="section-content">{escaped_content}</div>
            </div>
        """

            # Add the conclusion
            html_output += f"""    <div class="footer">
                <p>Sie können das Wissen jetzt bei Ihrer Arbeit umsetzen. Dadurch steigern Sie das
                Sicherheitsbewusstsein in {html.escape(organization)} und Sie schützen sich, Ihre Kolleginnen
                und Kollegen und die gesamte Organisation.</p>
                <p>Gut gemacht!</p>
            </div>
        </body>
        </html>"""

            return html_output
        except Exception as e:
            logger.error(f"Error generating HTML script: {e}")
            return f"""<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Fehler bei der Generierung</title>
        </head>
        <body>
            <h1>Fehler bei der Generierung des HTML-Skripts</h1>
            <p>Bei der Erstellung des HTML-Skripts ist ein Fehler aufgetreten: {html.escape(str(e))}</p>
        </body>
        </html>"""

    def test_vector_retrieval(self, query: str) -> List[Document]:
        """
        Tests the vector database retrieval with a query and returns the results.
        Useful for debugging vector database issues.

        Args:
            query: The query to test

        Returns:
            List of Document objects retrieved
        """
        try:
            # Try to retrieve documents with the query
            docs = self.vector_store_manager.retrieve_documents(query=query, k=3)
            
            # Log the results
            logger.info(f"Vector retrieval test for query '{query}':")
            logger.info(f"Retrieved {len(docs)} documents")
            
            for i, doc in enumerate(docs):
                source = doc.metadata.get('source', 'Unknown')
                logger.info(f"Doc {i+1}: {source[:50]}... Content: {doc.page_content[:100]}...")
                
            return docs
        except Exception as e:
            logger.error(f"Error testing vector retrieval: {e}")
            return []
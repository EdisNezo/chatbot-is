import html
import logging
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import re
from langchain.docstore.document import Document  # Add this if missing

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class DialogManager:
    """
    Implements a dialog-based process for creating an e-learning course.
    """

    def __init__(self, template_manager, llm_manager, vector_store_manager):
        """
        Initializes the DialogManager.

        Args:
            template_manager: TemplateManager instance
            llm_manager: LLMManager instance
            vector_store_manager: VectorStoreManager instance
        """
        self.template_manager = template_manager
        self.llm_manager = llm_manager
        self.vector_store_manager = vector_store_manager

        # Initialize conversation state
        self.conversation_state = {
            "current_step": "greeting",
            "context_info": {},
            "section_responses": {},
            "generated_content": {},  # Content generated by LLM per section
            "completed_sections": [],
            "current_section": None,
            "content_quality_checks": {},
            "current_section_question_count": 0
        }

        # List of context questions
        self.context_questions = [
        "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?",
        "Welche Mitarbeitergruppen sollen geschult werden?",
        "Wie lang sollte der E-Learning-Kurs maximal dauern?",
        "Mit welchen Arten von Informationen oder Daten arbeiten Ihre Mitarbeiter im Alltag?",
        "Wie kommunizieren Ihre Mitarbeiter typischerweise miteinander und mit externen Partnern?"
        ]

    def get_next_question(self) -> str:
        """
        Determines the next question based on the current conversation state.

        Returns:
            Next question as a string
        """
        if self.conversation_state["current_step"] == "greeting":
            # Switch to next step
            self.conversation_state["current_step"] = "context_gathering"
            return "Willkommen! Ich unterstütze Sie heute bei der Erstellung eines maßgeschneiderten E-Learning-Kurses zur Informationssicherheit. Um einen auf Ihre Bedürfnisse zugeschnittenen Kurs zu entwickeln, würde ich gerne mehr über Ihre Organisation erfahren. Für welche Art von Organisation erstellen wir diesen Kurs?"

        elif self.conversation_state["current_step"] == "context_gathering":
            # Find the next unanswered context question
            for question in self.context_questions:
                if question not in self.conversation_state["context_info"]:
                    return question

            # All context questions have been answered
            self.conversation_state["current_step"] = "template_navigation"
            return "Vielen Dank für diese Informationen! Jetzt werde ich Ihnen einige Fragen zu spezifischen Bereichen der Informationssicherheit stellen, damit wir einen gut angepassten Kurs erstellen können.\n\n" + self.get_next_template_question()

        elif self.conversation_state["current_step"] == "template_navigation":
            return self.get_next_template_question()

        elif self.conversation_state["current_step"] == "review":
            return "Ich habe basierend auf Ihren Eingaben einen E-Learning-Kurs zur Informationssicherheit entworfen. Möchten Sie das Ergebnis sehen?"

        elif self.conversation_state["current_step"] == "completion":
            return "Vielen Dank für Ihre Mitwirkung! Der E-Learning-Kurs wurde erfolgreich erstellt und kann jetzt heruntergeladen werden."

    def get_next_template_question(self) -> str:
        """
        Determines the next question based on the template with robust error handling.

        Returns:
            Next question as a string
        """
        
        # Section information
        section_id = next_section["id"]
        section_title = next_section["title"]
        section_description = next_section["description"]
        section_type = next_section.get("type", "generic")
        
        # Translation mapping for user-friendly questions
        user_friendly_questions = {
            "threat_awareness": f"Wie sieht ein typischer Arbeitstag in {organization} aus, besonders wenn Sie mit Informationen oder Kommunikation arbeiten?",
            "threat_identification": f"Ist Ihnen schon einmal etwas Ungewöhnliches oder Verdächtiges bei der Arbeit aufgefallen? Zum Beispiel seltsame E-Mails oder Anrufe?",
            "threat_impact_assessment": f"Was würde in {organization} passieren, wenn plötzlich wichtige Daten oder Systeme nicht mehr verfügbar wären?",
            "tactic_choice": f"Wie gehen Sie vor, wenn Sie etwas Verdächtiges bemerken? Haben Sie bestimmte Abläufe oder Ansprechpartner?",
            "tactic_justification": f"Was sind die Gründe für Ihre derzeitigen Sicherheitsmaßnahmen in {organization}?",
            "tactic_mastery": f"Können Sie mir konkrete Schritte oder Prozesse beschreiben, wie Sie mit vertraulichen Informationen umgehen?",
            "tactic_check_follow_up": f"Was passiert in {organization} nach einem Vorfall oder einer Störung? Wie wird das nachverfolgt?"
        }
    
    
    
        # Predefined questions for emergencies
        predefined_questions = {
            "threat_awareness": "Wie sieht ein typischer Arbeitstag in Ihrem Unternehmen aus, besonders in Bezug auf den Umgang mit externen E-Mails oder Informationen?",
            "threat_identification": "Sind Ihnen schon einmal verdächtige E-Mails oder andere Kommunikation aufgefallen? Was hat Sie stutzig gemacht?",
            "threat_impact_assessment": "Welche Auswirkungen hätte es auf Ihre tägliche Arbeit, wenn wichtige Daten plötzlich nicht mehr verfügbar wären?",
            "tactic_choice": "Wie gehen Sie aktuell vor, wenn Sie etwas Verdächtiges bemerken?",
            "tactic_justification": "Warum halten Sie die aktuellen Sicherheitsmaßnahmen in Ihrem Unternehmen für sinnvoll?",
            "tactic_mastery": "Welche konkreten Schritte unternehmen Sie, wenn Sie eine verdächtige E-Mail erhalten?",
            "tactic_check_follow_up": "Was passiert in Ihrem Unternehmen, nachdem ein Sicherheitsvorfall gemeldet wurde?"
        }

        # Find the next uncompleted section
        next_section = self.template_manager.get_next_section(self.conversation_state["completed_sections"])
        
        if is_new_section:
            # Test the vector database with a simple query
            test_query = f"Beispiel {next_section['title']}"
            test_docs = self.test_vector_retrieval(test_query)
            if not test_docs:
                logger.warning(f"Vector retrieval test returned no results for '{test_query}'")

        if next_section is None:
            # All sections have been completed
            self.conversation_state["current_step"] = "review"
            return self.get_next_question()

        # Check if we're switching to a new section
        current_section = self.conversation_state.get("current_section")
        is_new_section = current_section != next_section["id"]

        # Initialize question_error_count if not present
        if "question_error_count" not in self.conversation_state:
            self.conversation_state["question_error_count"] = 0

        if is_new_section:
            # Reset counters for new section
            self.conversation_state["current_section_question_count"] = 0
            self.conversation_state["question_error_count"] = 0

        # Section information
        section_id = next_section["id"]
        section_title = next_section["title"]
        section_description = next_section["description"]
        section_type = next_section.get("type", "generic")

        try:
            # Get relevant documents for this section
            retrieval_queries = self.generate_retrieval_queries(section_title, section_id)

            retrieved_docs = self.vector_store_manager.retrieve_with_multiple_queries(
                queries=retrieval_queries,
                filter={"section_type": section_type},
                top_k=2  # Reduce to 2 instead of 3 for less memory usage
            )

            # Limit context to max. 1000 characters
            context_text = "\n\n".join([doc.page_content for doc in retrieved_docs])
            if len(context_text) > 1000:
                context_text = context_text[:1000] + "..."

            # Context information for question generation
            organization = self.conversation_state["context_info"].get(
                "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")
            audience = self.conversation_state["context_info"].get(
                "Welche Mitarbeitergruppen sollen geschult werden?", "")

            # Try to generate question with LLM
            question = self.llm_manager.generate_question(
                section_title=section_title,
                section_description=section_description,
                context_text=context_text,
                organization=organization,
                audience=audience
            )

            # Reset error counter on success
            self.conversation_state["question_error_count"] = 0

        except Exception as e:
            # Log error
            logger.warning(f"Error in question generation, using user-friendly fallback for {section_id}")
            question = user_friendly_questions.get(section_id, f"Können Sie mir mehr über Ihre tägliche Arbeit in {organization} erzählen?")

            # Increase error counter
            self.conversation_state["question_error_count"] += 1

            # Skip to next section if too many errors
            if self.conversation_state["question_error_count"] > 2:
                logger.warning(f"Too many errors with {section_title}, skipping section")
                self.conversation_state["completed_sections"].append(section_id)
                return self.get_next_template_question()

        

        # Update the conversation state
        self.conversation_state["current_section"] = section_id

        # Add transition info for new section
        if is_new_section:
            return f"Nun kommen wir zum Abschnitt '{section_title}'.\n\n{question}"

        return question

    def generate_retrieval_queries(self, section_title: str, section_id: str) -> List[str]:
        """
        Generates retrieval queries for a section of the template.

        Args:
            section_title: Title of the section
            section_id: ID of the section

        Returns:
            List of retrieval queries
        """
        # Base query from the section title
        base_query = section_title

        # Context-specific queries
        organization = self.conversation_state["context_info"].get(
            "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")
        audience = self.conversation_state["context_info"].get(
            "Welche Mitarbeitergruppen sollen geschult werden?", "")
        compliance = self.conversation_state["context_info"].get(
            "Gibt es spezifische Compliance-Anforderungen oder Branchenstandards, die berücksichtigt werden müssen?", "")

        # Industry-specific query
        industry_query = f"Informationssicherheit für {organization}"

        # Improved section-specific query templates according to the example script
        section_templates = {
            "threat_awareness": f"Bedrohungsbewusstsein Kontext Informationssicherheit {organization}",
            "threat_identification": f"Merkmale Bedrohungserkennung Informationssicherheit {organization}",
            "threat_impact_assessment": f"Konsequenzen Bedrohungen Informationssicherheit {organization}",
            "tactic_choice": f"Handlungsoptionen Sicherheitsmaßnahmen {organization}",
            "tactic_justification": f"Begründung Rechtfertigung Sicherheitsmaßnahmen {organization}",
            "tactic_mastery": f"Konkrete Schritte Umsetzung Sicherheitsmaßnahmen {organization}",
            "tactic_check_follow_up": f"Anschlusshandlungen Nach Sicherheitsvorfall {organization}"
        }

        # Use the corresponding template if available
        section_query = section_templates.get(section_id, "")

        # Add compliance-specific query if available
        compliance_query = ""
        if compliance and compliance.strip():
            compliance_query = f"Informationssicherheit {compliance} {organization}"

        # Specific queries for certain sections
        specific_queries = []
        if section_id == "threat_awareness":
            specific_queries.append(f"Alltägliche Situationen Informationssicherheit {organization}")
        elif section_id == "threat_identification":
            specific_queries.append(f"Phishing Erkennung Merkmale {organization}")
        elif section_id == "threat_impact_assessment":
            specific_queries.append(f"Konsequenzen Datenverlust Cyberangriff {organization}")
        elif section_id == "tactic_choice":
            specific_queries.append(f"Schutzmaßnahmen Verdächtige E-Mails {organization}")
        elif section_id == "tactic_justification":
            specific_queries.append(f"Warum E-Mail-Sicherheit wichtig {organization}")
        elif section_id == "tactic_mastery":
            specific_queries.append(f"Schritte Überprüfung Verdächtige E-Mails {organization}")
        elif section_id == "tactic_check_follow_up":
            specific_queries.append(f"Meldeverfahren Informationssicherheitsvorfälle {organization}")

        # Create the list of queries
        queries = [base_query, industry_query]

        if section_query:
            queries.append(section_query)

        if compliance_query:
            queries.append(compliance_query)

        queries.extend(specific_queries)

    def process_user_response(self, response: str) -> str:
        """
        Processes the user's response and updates the conversation state.

        Args:
            response: User's response

        Returns:
            Next question or message
        """
        if self.conversation_state["current_step"] == "context_gathering":
            # Determine which context question is currently being answered
            for question in self.context_questions:
                if question not in self.conversation_state["context_info"]:
                    self.conversation_state["context_info"][question] = response
                    break

        elif self.conversation_state["current_step"] == "template_navigation":
            # Increase the question counter for the current section
            self.conversation_state["current_section_question_count"] += 1

            # Check if we've reached the maximum number of questions or if the answer is sufficient
            max_questions_reached = self.conversation_state["current_section_question_count"] >= 3

            if max_questions_reached or self.is_response_adequate(response):
                # Save the response for the current section
                current_section = self.conversation_state["current_section"]
                self.conversation_state["section_responses"][current_section] = response

                # Generate content for this section
                self._generate_section_content(current_section)

                self.conversation_state["completed_sections"].append(current_section)

                # Reset the question counter for the next section
                self.conversation_state["current_section_question_count"] = 0
            else:
                # Request a more detailed answer
                return self.generate_followup_question(response)

        elif self.conversation_state["current_step"] == "review":
            # Check if the user wants to see the result
            if any(word in response.lower() for word in ["ja", "gerne", "zeigen", "ansehen"]):
                self.conversation_state["current_step"] = "completion"
                return "Hier ist der entworfene E-Learning-Kurs zur Informationssicherheit basierend auf Ihren Eingaben:\n\n" + self.get_script_summary()
            else:
                # Ask again if the user wants to see the result
                return "Möchten Sie den erstellten E-Learning-Kurs sehen? Bitte antworten Sie mit 'Ja' oder 'Nein'."

        # Determine the next question
        return self.get_next_question()

    def is_response_adequate(self, response: str) -> bool:
        """
        Checks if the user's response is sufficiently detailed.

        Args:
            response: User's response

        Returns:
            True if the response is sufficient, False otherwise
        """
        # Improved heuristic: Check the length and content of the response
        min_word_count = 15
        word_count = len(response.split())

        # Check if the response is relevant to the current section
        current_section_id = self.conversation_state["current_section"]
        current_section = self.template_manager.get_section_by_id(current_section_id)

        if current_section:
            # Create a list of relevant terms for this section
            relevant_terms = []

            if "threat" in current_section_id:
                relevant_terms.extend(["gefahr", "risiko", "bedrohung", "sicherheit", "schaden"])
            if "tactic" in current_section_id:
                relevant_terms.extend(["maßnahme", "vorgehen", "schutz", "handlung", "prozess"])

            # Check if at least one relevant term appears in the response
            has_relevant_term = any(term in response.lower() for term in relevant_terms)

            return word_count >= min_word_count and has_relevant_term

        return word_count >= min_word_count

    def generate_followup_question(self, response: str) -> str:
        """
        Generates a follow-up question for an insufficient response.

        Args:
            response: Insufficient response from the user

        Returns:
            Follow-up question as a string
        """
        current_section_id = self.conversation_state["current_section"]
        section = self.template_manager.get_section_by_id(current_section_id)

        followup_prompt = f"""
        Die folgende Antwort des Kunden zu einer Frage über {section['title']} ist recht kurz oder allgemein:

        "{response}"

        Formuliere eine freundliche Nachfrage, die mehr Details zu ihren Prozessen oder ihrem Arbeitskontext erbittet.
        Die Nachfrage sollte:
        1. Wertschätzend für die bisherige Antwort sein
        2. Konkrete Aspekte ansprechen, zu denen mehr Details hilfreich wären
        3. Keine Fachbegriffe aus der Informationssicherheit verwenden
        4. Offen formuliert sein, um ausführlichere Antworten zu fördern
        5. Auf den spezifischen Abschnittstyp "{section['title']}" zugeschnitten sein

        Für "Threat Awareness" beispielsweise könntest du nach konkreten Situationen im Arbeitsalltag fragen.
        Für "Tactic Mastery" könntest du nach spezifischen Schritten in bestimmten Prozessen fragen.

        Stelle nur die Nachfrage, keine Einleitung oder zusätzliche Erklärungen.
        """

        followup_question = self.llm_manager.llm(followup_prompt)

        return followup_question

    def _generate_section_content(self, section_id: str) -> None:
        """
        Generates the content for a section and performs quality checks.

        Args:
            section_id: ID of the section
        """
        # Get the user's response
        user_response = self.conversation_state["section_responses"][section_id]
        section = self.template_manager.get_section_by_id(section_id)

        # Extract key information for retrieval
        key_concepts = self.llm_manager.extract_key_information(
            section_type=section.get("type", "generic"),
            user_response=user_response
        )

        # Generate retrieval queries based on key concepts
        retrieval_queries = [
            f"{concept} Informationssicherheit"
            for concept in key_concepts
        ]

        # Add section-specific queries
        retrieval_queries.extend(self.generate_retrieval_queries(section["title"], section_id))

        # Get relevant documents
        retrieved_docs = self.vector_store_manager.retrieve_with_multiple_queries(
            queries=retrieval_queries,
            filter={"section_type": section.get("type", "generic")},
            top_k=5
        )

        # Extract context from retrieved documents
        context_text = "\n\n".join([doc.page_content for doc in retrieved_docs])

        # Generate content for this section
        organization = self.conversation_state["context_info"].get(
            "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")
        audience = self.conversation_state["context_info"].get(
            "Welche Mitarbeitergruppen sollen geschult werden?", "")
        duration = self.conversation_state["context_info"].get(
            "Wie lang sollte der E-Learning-Kurs maximal dauern?", "")

        content = self.llm_manager.generate_content(
            section_title=section["title"],
            section_description=section.get("description", ""),
            user_response=user_response,
            organization=organization,
            audience=audience,
            duration=duration,
            context_text=context_text
        )

        # Perform advanced hallucination check
        advanced_check = self.llm_manager.advanced_hallucination_detection(content)

        # Perform quality check
        has_issues, verified_content = self.llm_manager.check_hallucinations(
            content=content,
            user_input=user_response,
            context_text=context_text
        )

        # Save the result of the quality check
        self.conversation_state["content_quality_checks"][section_id] = {
            "has_issues": has_issues,
            "confidence_score": advanced_check["confidence_score"],
            "suspicious_sections": advanced_check["suspicious_sections"]
        }

        # Save the generated content
        self.conversation_state["generated_content"][section_id] = verified_content

    def generate_script(self) -> Dict[str, Any]:
        """
        Generates the final e-learning course.

        Returns:
            Course as a dictionary
        """
        # Create a script from the generated contents
        script = self.template_manager.create_script_from_responses(
            self.conversation_state["generated_content"],
            self.conversation_state["context_info"]
        )

        return script

    def get_script_summary(self) -> str:
        """
        Creates a summary of the generated course in the format of the example script.

        Returns:
            Summary as a string
        """
        # Generate the course
        script = self.generate_script()

        # Create a summary in the format of the example script
        organization = self.conversation_state["context_info"].get(
            "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")

        summary = f"# {script.get('title', 'E-Learning-Kurs zur Informationssicherheit')}\n\n"

        if "description" in script:
            summary += f"{script['description']}\n\n"

        # Format the sections in the desired table format
        for section in script["sections"]:
            title = section["title"]
            content = section.get("content", "Kein Inhalt verfügbar.")

            summary += f"## {title}\n\n"
            summary += f"{content}\n\n"

            # Add note on quality check if relevant
            section_id = section["id"]
            if section_id in self.conversation_state["content_quality_checks"]:
                quality_check = self.conversation_state["content_quality_checks"][section_id]
                if quality_check["has_issues"]:
                    summary += "*Hinweis: Dieser Abschnitt wurde nach der Qualitätsprüfung überarbeitet.*\n\n"

        # Add closing message, similar to the example script
        summary += "Sie können das Wissen jetzt bei Ihrer Arbeit umsetzen. Dadurch steigern Sie das\n"
        summary += f"Sicherheitsbewusstsein in {organization} und Sie schützen sich, Ihre Kolleginnen\n"
        summary += "und Kollegen und die gesamte Organisation.\n\n"
        summary += "Gut gemacht!\n"

        return summary

    def generate_html_script(self) -> str:
        """
        Generates an HTML version of the script in the format of the example script.

        Returns:
            HTML-formatted script
        """
        script = self.generate_script()
        organization = self.conversation_state["context_info"].get(
            "Für welche Art von Organisation erstellen wir den E-Learning-Kurs (z.B. Krankenhaus, Bank, Behörde)?", "")

        html_output = f"""<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>{html.escape(script.get('title', 'E-Learning-Kurs zur Informationssicherheit'))}</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; }}
            h1 {{ color: #2c3e50; }}
            .section {{ margin-bottom: 20px; }}
            .section-title {{ background-color: #f5f5f5; padding: 10px; font-weight: bold; }}
            .section-content {{ padding: 10px; }}
            .footer {{ margin-top: 30px; border-top: 1px solid #ddd; padding-top: 15px; }}
        </style>
    </head>
    <body>
        <h1>{html.escape(script.get('title', 'E-Learning-Kurs zur Informationssicherheit'))}</h1>
        <p>{html.escape(script.get('description', ''))}</p>
    """

        # Add the sections
        for section in script["sections"]:
            title = section["title"]
            content = section.get("content", "Kein Inhalt verfügbar.")

            html_output += f"""    <div class="section">
            <div class="section-title">{html.escape(title)}</div>"""

            # Process content with backslashes outside the f-string
            escaped_content = html.escape(content).replace('\n', '<br>')
            html_output += f"""
            <div class="section-content">{escaped_content}</div>
        </div>
    """

        # Add the conclusion
        html_output += f"""    <div class="footer">
            <p>Sie können das Wissen jetzt bei Ihrer Arbeit umsetzen. Dadurch steigern Sie das
            Sicherheitsbewusstsein in {html.escape(organization)} und Sie schützen sich, Ihre Kolleginnen
            und Kollegen und die gesamte Organisation.</p>
            <p>Gut gemacht!</p>
        </div>
    </body>
    </html>"""

        return html_output

    def save_script(self, output_path: str, format: str = "txt") -> None:
        """
        Saves the generated course to a file.

        Args:
            output_path: Path to the output file
            format: Format of the output ("txt", "json", or "html")
        """
        try:
            if format == "json":
                script = self.generate_script()
                with open(output_path, "w", encoding="utf-8") as f:
                    json.dump(script, f, ensure_ascii=False, indent=2)
            elif format == "html":
                html_script = self.generate_html_script()
                with open(output_path, "w", encoding="utf-8") as f:
                    f.write(html_script)
            else:  # Default: txt
                script_summary = self.get_script_summary()
                with open(output_path, "w", encoding="utf-8") as f:
                    f.write(script_summary)

            logger.info(f"E-Learning course saved: {output_path}")
        except Exception as e:
            logger.error(f"Error saving e-learning course: {e}")
            
            
    def fix_dialog_manager():
        """
        Update the generate_retrieval_queries function in dialog_manager.py
        """
        file_path = "modules/dialog_manager.py"
        
        with open(file_path, 'r') as file:
            content = file.read()
        
        # Fix the missing return statement in generate_retrieval_queries
        if "def generate_retrieval_queries" in content and "return queries" not in content:
            # Find the function definition
            import re
            pattern = r"(def generate_retrieval_queries.*?queries\.extend\(specific_queries\)\s*)(    \n|$)"
            replacement = r"\1\n    return queries\n\2"
            
            # Apply the fix
            fixed_content = re.sub(pattern, replacement, content, flags=re.DOTALL)
            
            # Write the fixed content
            with open(file_path, 'w') as file:
                file.write(fixed_content)
            
            print("Fixed dialog_manager.py - added missing return statement")
        else:
            print("No fix needed for dialog_manager.py or fix already applied")
            
    def test_vector_retrieval(self, query: str) -> List[Document]:
        """
        Tests the vector database retrieval with a query and returns the results.
        Useful for debugging vector database issues.

        Args:
            query: The query to test

        Returns:
            List of Document objects retrieved
        """
        try:
            # Try to retrieve documents with the query
            docs = self.vector_store_manager.retrieve_documents(query=query, k=3)
            
            # Log the results
            logger.info(f"Vector retrieval test for query '{query}':")
            logger.info(f"Retrieved {len(docs)} documents")
            
            for i, doc in enumerate(docs):
                source = doc.metadata.get('source', 'Unknown')
                logger.info(f"Doc {i+1}: {source[:50]}... Content: {doc.page_content[:100]}...")
                
            return docs
        except Exception as e:
            logger.error(f"Error testing vector retrieval: {e}")
            return []